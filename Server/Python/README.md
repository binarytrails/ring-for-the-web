# Python <-> C++

## Introduction

It appears that there are tons of ways to interact with C / C++ in Python. I'm focusing on delegating the control of the Python RESTful API to the Ring daemon written in C++. Here is an exhaustive list of the technologies I found. Some of them are combined to form a method of implementation i.e. PyPy + Cffi, Ctypes with others etc. CPython is the default Python implementation written in C.

 | Part of CPython | Compiled | Autogenerated
---|---|---|---
Python-C-API | Y | Y | N
Ctypes       | Y | N | N
Swig         | N | Y | Y
Cython       | N | Y | Y
PyPy         | N | Y | N
Cffi         | N | N | N

### Python / C API

By importing the Python.h library header you are able to embed a Python interpreter inside the C / C++.

[Supported types mappings](https://docs.python.org/2/c-api/concrete.html)

### Ctypes

It's a standard-library module that can load shared libraries and call functions from them without the use of a C compiler or any new C code.

### Swig

You create an interface using Swig syntax that will generate C code for bindings.

### Cython

It is a language similar to Python that translates to C and then compiles into an extension module. Cython code can define Python classes and functions, but also call C functions and perform other C operations directly. The code written with C semantics is translated to C; code with Python semantics is translated for the appropriate use with the CPython API. Cython is the translator between the two.

### PyPy

It's an alternative Python implementation using [Just In Time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation).

### CFFI

It is used for binding to C libraries with an interface borrowed from Lua. It is based on the same underlying library (libffi) as ctypes, but is more compatible with PyPy. It gets its C interface definitions by parsing C header files to avoid translating them to Python.

## Which one is better?

I decided to implement the Python / C API. Here are my reasons:

1. Embedding the Python interpreter delegates direct control to the C++ bridge.
2. Python RESTful API is not polluted by a variety of interlanguage bindings.
3. It is possible to easily change the RESTful API without changing the type mappings.
4. The online and in-header documentation is very complete.

The other options may be implemented later. Here is an interesting article: [Cython vs CFFI](https://eev.ee/blog/2013/09/13/cython-versus-cffi/).

## Work in progress

1. ~~Implement examples of RESTful servers~~
2. Integrate to the Ring Daemon

## Getting started

It may be a good idea to setup a virtualenv for python:

    virtualenv -p python2.7 ENV
    source ENV/bin/activate
    pip install -r requirements.txt
    #deactivate

### Python / C API

I tried using the most recent [Python 3 API](https://docs.python.org/3.5/c-api/index.html) and encountered weird errors. It may just be me but in the Python world, [2.7 is the most widely used](http://www.randalolson.com/2015/01/30/python-usage-survey-2014/) which implies that the majority of examples were written for it. Therefore, I will use [Python 2.7 API](https://docs.python.org/2.7/c-api/index.html).

    # install python-dev to have <Python.h>
    gcc -I/usr/include/python2.7 -lpython2.7 main.cpp -o main
    
    # Using pkg-config on Arch Linux
    gcc $(pkg-config --cflags --libs python2) main.c -o main    # C
    gcc $(pkg-config --libs python2) main.cpp -o main           # C++

